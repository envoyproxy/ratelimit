// Code generated by MockGen. DO NOT EDIT.
// Source: ./src/algorithm/ratelimit_algorithm.go

// Package mock_algorithm is a generated GoMock package.
package mock_algorithm

import (
	envoy_extensions_common_ratelimit_v3 "github.com/envoyproxy/go-control-plane/envoy/extensions/common/ratelimit/v3"
	config "github.com/envoyproxy/ratelimit/src/config"
	limiter "github.com/envoyproxy/ratelimit/src/limiter"
	driver "github.com/envoyproxy/ratelimit/src/redis/driver"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockRatelimitAlgorithm is a mock of RatelimitAlgorithm interface
type MockRatelimitAlgorithm struct {
	ctrl     *gomock.Controller
	recorder *MockRatelimitAlgorithmMockRecorder
}

// MockRatelimitAlgorithmMockRecorder is the mock recorder for MockRatelimitAlgorithm
type MockRatelimitAlgorithmMockRecorder struct {
	mock *MockRatelimitAlgorithm
}

// NewMockRatelimitAlgorithm creates a new mock instance
func NewMockRatelimitAlgorithm(ctrl *gomock.Controller) *MockRatelimitAlgorithm {
	mock := &MockRatelimitAlgorithm{ctrl: ctrl}
	mock.recorder = &MockRatelimitAlgorithmMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRatelimitAlgorithm) EXPECT() *MockRatelimitAlgorithmMockRecorder {
	return m.recorder
}

// GenerateCacheKey mocks base method
func (m *MockRatelimitAlgorithm) GenerateCacheKey(domain string, descriptor *envoy_extensions_common_ratelimit_v3.RateLimitDescriptor, limit *config.RateLimit) limiter.CacheKey {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateCacheKey", domain, descriptor, limit)
	ret0, _ := ret[0].(limiter.CacheKey)
	return ret0
}

// GenerateCacheKey indicates an expected call of GenerateCacheKey
func (mr *MockRatelimitAlgorithmMockRecorder) GenerateCacheKey(domain, descriptor, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateCacheKey", reflect.TypeOf((*MockRatelimitAlgorithm)(nil).GenerateCacheKey), domain, descriptor, limit)
}

// AppendPipeline mocks base method
func (m *MockRatelimitAlgorithm) AppendPipeline(client driver.Client, pipeline driver.Pipeline, key string, hitsAddend uint32, result interface{}, expirationSeconds int64) driver.Pipeline {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AppendPipeline", client, pipeline, key, hitsAddend, result, expirationSeconds)
	ret0, _ := ret[0].(driver.Pipeline)
	return ret0
}

// AppendPipeline indicates an expected call of AppendPipeline
func (mr *MockRatelimitAlgorithmMockRecorder) AppendPipeline(client, pipeline, key, hitsAddend, result, expirationSeconds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendPipeline", reflect.TypeOf((*MockRatelimitAlgorithm)(nil).AppendPipeline), client, pipeline, key, hitsAddend, result, expirationSeconds)
}

// PopulateStats mocks base method
func (m *MockRatelimitAlgorithm) PopulateStats() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PopulateStats")
}

// PopulateStats indicates an expected call of PopulateStats
func (mr *MockRatelimitAlgorithmMockRecorder) PopulateStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PopulateStats", reflect.TypeOf((*MockRatelimitAlgorithm)(nil).PopulateStats))
}

// CalculateResetDuration mocks base method
func (m *MockRatelimitAlgorithm) CalculateResetDuration() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CalculateResetDuration")
}

// CalculateResetDuration indicates an expected call of CalculateResetDuration
func (mr *MockRatelimitAlgorithmMockRecorder) CalculateResetDuration() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalculateResetDuration", reflect.TypeOf((*MockRatelimitAlgorithm)(nil).CalculateResetDuration))
}

// IsUnderLimit mocks base method
func (m *MockRatelimitAlgorithm) IsUnderLimit() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "IsUnderLimit")
}

// IsUnderLimit indicates an expected call of IsUnderLimit
func (mr *MockRatelimitAlgorithmMockRecorder) IsUnderLimit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUnderLimit", reflect.TypeOf((*MockRatelimitAlgorithm)(nil).IsUnderLimit))
}
