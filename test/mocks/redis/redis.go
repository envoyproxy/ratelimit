// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/lyft/ratelimit/src/redis (interfaces: RateLimitCache,Pool,Connection,Response,TimeSource,JitterRandSource)

// Package mock_redis is a generated GoMock package.
package mock_redis

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	ratelimit "github.com/lyft/ratelimit/proto/ratelimit"
	config "github.com/lyft/ratelimit/src/config"
	redis "github.com/lyft/ratelimit/src/redis"
	reflect "reflect"
)

// MockRateLimitCache is a mock of RateLimitCache interface
type MockRateLimitCache struct {
	ctrl     *gomock.Controller
	recorder *MockRateLimitCacheMockRecorder
}

// MockRateLimitCacheMockRecorder is the mock recorder for MockRateLimitCache
type MockRateLimitCacheMockRecorder struct {
	mock *MockRateLimitCache
}

// NewMockRateLimitCache creates a new mock instance
func NewMockRateLimitCache(ctrl *gomock.Controller) *MockRateLimitCache {
	mock := &MockRateLimitCache{ctrl: ctrl}
	mock.recorder = &MockRateLimitCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRateLimitCache) EXPECT() *MockRateLimitCacheMockRecorder {
	return m.recorder
}

// DoLimit mocks base method
func (m *MockRateLimitCache) DoLimit(arg0 context.Context, arg1 *ratelimit.RateLimitRequest, arg2 []*config.RateLimit) []*ratelimit.RateLimitResponse_DescriptorStatus {
	ret := m.ctrl.Call(m, "DoLimit", arg0, arg1, arg2)
	ret0, _ := ret[0].([]*ratelimit.RateLimitResponse_DescriptorStatus)
	return ret0
}

// DoLimit indicates an expected call of DoLimit
func (mr *MockRateLimitCacheMockRecorder) DoLimit(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoLimit", reflect.TypeOf((*MockRateLimitCache)(nil).DoLimit), arg0, arg1, arg2)
}

// MockPool is a mock of Pool interface
type MockPool struct {
	ctrl     *gomock.Controller
	recorder *MockPoolMockRecorder
}

// MockPoolMockRecorder is the mock recorder for MockPool
type MockPoolMockRecorder struct {
	mock *MockPool
}

// NewMockPool creates a new mock instance
func NewMockPool(ctrl *gomock.Controller) *MockPool {
	mock := &MockPool{ctrl: ctrl}
	mock.recorder = &MockPoolMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockPool) EXPECT() *MockPoolMockRecorder {
	return m.recorder
}

// Get mocks base method
func (m *MockPool) Get() redis.Connection {
	ret := m.ctrl.Call(m, "Get")
	ret0, _ := ret[0].(redis.Connection)
	return ret0
}

// Get indicates an expected call of Get
func (mr *MockPoolMockRecorder) Get() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockPool)(nil).Get))
}

// Put mocks base method
func (m *MockPool) Put(arg0 redis.Connection) {
	m.ctrl.Call(m, "Put", arg0)
}

// Put indicates an expected call of Put
func (mr *MockPoolMockRecorder) Put(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Put", reflect.TypeOf((*MockPool)(nil).Put), arg0)
}

// MockConnection is a mock of Connection interface
type MockConnection struct {
	ctrl     *gomock.Controller
	recorder *MockConnectionMockRecorder
}

// MockConnectionMockRecorder is the mock recorder for MockConnection
type MockConnectionMockRecorder struct {
	mock *MockConnection
}

// NewMockConnection creates a new mock instance
func NewMockConnection(ctrl *gomock.Controller) *MockConnection {
	mock := &MockConnection{ctrl: ctrl}
	mock.recorder = &MockConnectionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockConnection) EXPECT() *MockConnectionMockRecorder {
	return m.recorder
}

// PipeAppend mocks base method
func (m *MockConnection) PipeAppend(arg0 string, arg1 ...interface{}) {
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "PipeAppend", varargs...)
}

// PipeAppend indicates an expected call of PipeAppend
func (mr *MockConnectionMockRecorder) PipeAppend(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PipeAppend", reflect.TypeOf((*MockConnection)(nil).PipeAppend), varargs...)
}

// PipeResponse mocks base method
func (m *MockConnection) PipeResponse() redis.Response {
	ret := m.ctrl.Call(m, "PipeResponse")
	ret0, _ := ret[0].(redis.Response)
	return ret0
}

// PipeResponse indicates an expected call of PipeResponse
func (mr *MockConnectionMockRecorder) PipeResponse() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PipeResponse", reflect.TypeOf((*MockConnection)(nil).PipeResponse))
}

// MockResponse is a mock of Response interface
type MockResponse struct {
	ctrl     *gomock.Controller
	recorder *MockResponseMockRecorder
}

// MockResponseMockRecorder is the mock recorder for MockResponse
type MockResponseMockRecorder struct {
	mock *MockResponse
}

// NewMockResponse creates a new mock instance
func NewMockResponse(ctrl *gomock.Controller) *MockResponse {
	mock := &MockResponse{ctrl: ctrl}
	mock.recorder = &MockResponseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockResponse) EXPECT() *MockResponseMockRecorder {
	return m.recorder
}

// Int mocks base method
func (m *MockResponse) Int() int64 {
	ret := m.ctrl.Call(m, "Int")
	ret0, _ := ret[0].(int64)
	return ret0
}

// Int indicates an expected call of Int
func (mr *MockResponseMockRecorder) Int() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Int", reflect.TypeOf((*MockResponse)(nil).Int))
}

// MockTimeSource is a mock of TimeSource interface
type MockTimeSource struct {
	ctrl     *gomock.Controller
	recorder *MockTimeSourceMockRecorder
}

// MockTimeSourceMockRecorder is the mock recorder for MockTimeSource
type MockTimeSourceMockRecorder struct {
	mock *MockTimeSource
}

// NewMockTimeSource creates a new mock instance
func NewMockTimeSource(ctrl *gomock.Controller) *MockTimeSource {
	mock := &MockTimeSource{ctrl: ctrl}
	mock.recorder = &MockTimeSourceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockTimeSource) EXPECT() *MockTimeSourceMockRecorder {
	return m.recorder
}

// UnixNow mocks base method
func (m *MockTimeSource) UnixNow() int64 {
	ret := m.ctrl.Call(m, "UnixNow")
	ret0, _ := ret[0].(int64)
	return ret0
}

// UnixNow indicates an expected call of UnixNow
func (mr *MockTimeSourceMockRecorder) UnixNow() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnixNow", reflect.TypeOf((*MockTimeSource)(nil).UnixNow))
}

// MockJitterRandSource is a mock of JitterRandSource interface
type MockJitterRandSource struct {
	ctrl     *gomock.Controller
	recorder *MockJitterRandSourceMockRecorder
}

// MockJitterRandSourceMockRecorder is the mock recorder for MockJitterRandSource
type MockJitterRandSourceMockRecorder struct {
	mock *MockJitterRandSource
}

// NewMockJitterRandSource creates a new mock instance
func NewMockJitterRandSource(ctrl *gomock.Controller) *MockJitterRandSource {
	mock := &MockJitterRandSource{ctrl: ctrl}
	mock.recorder = &MockJitterRandSourceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockJitterRandSource) EXPECT() *MockJitterRandSourceMockRecorder {
	return m.recorder
}

// Int63 mocks base method
func (m *MockJitterRandSource) Int63() int64 {
	ret := m.ctrl.Call(m, "Int63")
	ret0, _ := ret[0].(int64)
	return ret0
}

// Int63 indicates an expected call of Int63
func (mr *MockJitterRandSourceMockRecorder) Int63() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Int63", reflect.TypeOf((*MockJitterRandSource)(nil).Int63))
}

// Seed mocks base method
func (m *MockJitterRandSource) Seed(arg0 int64) {
	m.ctrl.Call(m, "Seed", arg0)
}

// Seed indicates an expected call of Seed
func (mr *MockJitterRandSourceMockRecorder) Seed(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Seed", reflect.TypeOf((*MockJitterRandSource)(nil).Seed), arg0)
}
